<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Atelier : Contraste de Luminosité Pédagogique</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #f4f7f6; display: flex; flex-direction: column; align-items: center; padding: 10px; user-select: none; }
        h2 { color: #2c3e50; margin: 5px 0; }
        .instructions { background: #fff3cd; border-left: 5px solid #ffc107; padding: 10px; border-radius: 4px; color: #856404; max-width: 800px; text-align: center; font-size: 0.9em; }
        
        .toolbar {
            background: white; padding: 10px 25px; border-radius: 50px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.1); margin: 15px 0; display: flex; gap: 15px; align-items: center;
        }
        .color-selector { width: 32px; height: 32px; border-radius: 50%; cursor: pointer; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.2); transition: transform 0.2s; }
        .color-selector:hover { transform: scale(1.1); }
        .color-selector.active { border-color: #34495e; transform: scale(1.2); }
        
        .btn { padding: 8px 18px; border: none; border-radius: 20px; cursor: pointer; font-weight: bold; color: white; transition: 0.2s; font-size: 0.9em; }
        .btn-clear { background: #e74c3c; } .btn-clear:hover { background: #c0392b; }
        .btn-undo { background: #95a5a6; } .btn-undo:hover { background: #7f8c8d; }

        #canvas-container { 
            position: relative; box-shadow: 0 10px 30px rgba(0,0,0,0.1); 
            border-radius: 12px; overflow: hidden; background: white;
        }
        canvas { display: block; outline: none; }
    </style>
</head>
<body>

    <h2>Atelier : Différence d'éclat (Pédagogique)</h2>
    <div class="instructions">
        <strong>Observation :</strong><br>
        L1 (Faible) : Jaune pâle, peu visible.<br>
        L2 (Forte) : Jaune foncé/Orange, très visible.
    </div>

    <div class="toolbar">
        <span style="color:#7f8c8d; font-weight:bold; margin-right:5px;">Fils :</span>
        <div class="color-selector active" style="background:#e74c3c;" onclick="setColor('red')" title="Rouge"></div>
        <div class="color-selector" style="background:#505050;" onclick="setColor('black')" title="Noir (Grisé)"></div>
        <div class="color-selector" style="background:#2ecc71;" onclick="setColor('green')" title="Vert"></div>
        <div style="width:1px; height:25px; background:#ddd; margin:0 10px;"></div>
        
        <button id="btnDel" class="btn btn-undo" onclick="deleteSelectedWire()">Suppr. fil</button>
        <button class="btn btn-clear" onclick="clearWires()">Tout effacer</button>
    </div>

    <div id="canvas-container">
        <canvas id="simCanvas" width="900" height="650" tabindex="1"></canvas>
    </div>

<script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const btnDel = document.getElementById('btnDel');
    const SHELF_WIDTH = 180;

    // --- CONFIGURATION ---
    const VAL_L1 = 0.10;
    const VAL_L2 = 0.35;
    
    // --- COULEURS ---
    const COL_RED = '#e74c3c';
    const COL_BLACK = '#505050';
    const COL_GREEN = '#2ecc71';

    // --- ÉTAT ---
    let components = [];
    let wires = []; 
    let currentColor = 'red';
    
    let draggingComp = null, dragOffset = {x:0, y:0};
    let drawingWire = false, wireStartTerm = null;
    let draggingHandle = null; 
    let selectedWire = null;
    let mouse = {x:0, y:0};

    // --- CLASSES ---
    class Component {
        constructor(id, type, x, y, label) {
            this.id = id; this.type = type; this.x = x; this.y = y; this.label = label;
            this.w = (type==='Gen')?160:(type==='Multi'?80:60);
            this.h = (type==='Gen')?110:(type==='Multi'?130:70);
            this.isOn = false;
            this.isGenOn = false;
            this.measuredValue = 0;
            this.currentIntensity = 0;
        }
        
        getTerminals() {
            const t = {};
            if(this.type === 'Gen') {
                t.m = {x:this.x+8, y:this.y+35, id:this.id+'_m', color:'black'};
                t.p = {x:this.x+38, y:this.y+35, id:this.id+'_p', color:'red'};
            } else if(this.type === 'Lamp') {
                t.l = {x:this.x-20, y:this.y+15, id:this.id+'_l', color:'black'};
                t.r = {x:this.x+20, y:this.y+15, id:this.id+'_r', color:'black'};
            } else if(this.type === 'Multi') {
                t.com = {x:this.x-15, y:this.y+50, id:this.id+'_com', color:'black'};
                t.a10 = {x:this.x+25, y:this.y+50, id:this.id+'_a10', color:'yellow'};
            }
            return t;
        }
        
        contains(mx, my) {
            return mx > this.x - this.w/2 && mx < this.x + this.w/2 && my > this.y - this.h/2 && my < this.y + this.h/2;
        }

        checkSwitchClick(mx, my) {
            if (this.type !== 'Gen') return false;
            if (mx > this.x - 70 && mx < this.x - 30 && my > this.y - 25 && my < this.y + 25) {
                this.isGenOn = !this.isGenOn;
                return true;
            }
            return false;
        }
    }

    // --- MOTEUR ELECTRIQUE ---
    function analyzeCircuit() {
        components.forEach(c => { 
            if(c.type !== 'Gen') c.isOn = false; 
            c.measuredValue = 0; 
            c.currentIntensity = 0;
        });

        const gen = components.find(c => c.type === 'Gen');
        if (!gen.isGenOn) return; 

        let adj = {}; 
        const connect = (id1, id2) => {
            if(!adj[id1]) adj[id1] = []; if(!adj[id2]) adj[id2] = [];
            adj[id1].push(id2); adj[id2].push(id1);
        };
        wires.forEach(w => connect(w.startId, w.endId));

        const multis = components.filter(c => c.type === 'Multi');
        multis.forEach(m => {
            const mt = m.getTerminals();
            connect(mt.com.id, mt.a10.id);
        });

        const genP = gen.getTerminals().p.id;
        const genM = gen.getTerminals().m.id;

        function getConnectedNodes(startNode, blockList = []) {
            let visited = new Set();
            let stack = [startNode];
            while(stack.length > 0) {
                let u = stack.pop();
                if(!visited.has(u)) {
                    visited.add(u);
                    if(adj[u]) {
                        adj[u].forEach(v => {
                            let isBlocked = false;
                            for(let pair of blockList) {
                                if((pair[0]===u && pair[1]===v) || (pair[0]===v && pair[1]===u)) isBlocked = true;
                            }
                            if(!isBlocked) stack.push(v);
                        });
                    }
                }
            }
            return visited;
        }

        const nodesPlus = getConnectedNodes(genP);
        const nodesMinus = getConnectedNodes(genM);

        ['l1', 'l2'].forEach(lid => {
            const l = components.find(c => c.id === lid);
            const lt = l.getTerminals();
            const c1 = nodesPlus.has(lt.l.id) && nodesMinus.has(lt.r.id);
            const c2 = nodesPlus.has(lt.r.id) && nodesMinus.has(lt.l.id);
            if(c1 || c2) {
                l.isOn = true;
                if(lid === 'l1') l.currentIntensity = VAL_L1;
                if(lid === 'l2') l.currentIntensity = VAL_L2;
            }
        });

        const l1 = components.find(c => c.id === 'l1');
        const l2 = components.find(c => c.id === 'l2');

        multis.forEach(m => {
            const mt = m.getTerminals();
            const blockList = [[mt.com.id, mt.a10.id]];
            const pSet = getConnectedNodes(genP, blockList);
            const mSet = getConnectedNodes(genM, blockList);

            function isLampPowered(lamp, pS, mS) {
                const t = lamp.getTerminals();
                return (pS.has(t.l.id) && mS.has(t.r.id)) || (mS.has(t.l.id) && pS.has(t.r.id));
            }

            let current = 0;
            if(l1.isOn && !isLampPowered(l1, pSet, mSet)) current += VAL_L1;
            if(l2.isOn && !isLampPowered(l2, pSet, mSet)) current += VAL_L2;
            if(current > 0) m.measuredValue = current;
        });
    }

    // --- INIT ---
    function init() {
        components = [
            new Component("gen", "Gen", 90, 80, "Géné"),
            new Component("l1", "Lamp", 90, 200, "L1"),
            new Component("l2", "Lamp", 90, 300, "L2"),
            new Component("a1", "Multi", 90, 420, "A1"),
            new Component("a2", "Multi", 90, 520, "A2"), 
            new Component("a3", "Multi", 90, 620, "A3")
        ];
        draw();
    }

    // --- INPUT ---
    function getMousePos(e) {
        const r = canvas.getBoundingClientRect();
        return { x: e.clientX - r.left, y: e.clientY - r.top };
    }
    function getTerminalUnderMouse(mx, my) {
        for(let c of components) {
            const terms = c.getTerminals();
            for(let key in terms) {
                const t = terms[key];
                if(Math.hypot(mx - t.x, my - t.y) < 20) return { c, id: t.id, x: t.x, y: t.y, color: t.color };
            }
        }
        return null;
    }
    function getWireHandleUnderMouse(mx, my) {
        for(let w of wires) {
            if(w.cp && Math.hypot(mx - w.cp.x, my - w.cp.y) < 15) return w;
        }
        return null;
    }
    function getWireUnderMouse(mx, my) {
        for(let w of wires) {
            const p1 = getTermPos(w.startC, w.startId);
            const p2 = getTermPos(w.endC, w.endId);
            const cp = w.cp || {x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2};
            for(let t=0; t<=1; t+=0.1) {
                const x = (1-t)*(1-t)*p1.x + 2*(1-t)*t*cp.x + t*t*p2.x;
                const y = (1-t)*(1-t)*p1.y + 2*(1-t)*t*cp.y + t*t*p2.y;
                if(Math.hypot(mx-x, my-y) < 10) return w;
            }
        }
        return null;
    }

    canvas.addEventListener('mousedown', e => {
        mouse = getMousePos(e);
        const wh = getWireHandleUnderMouse(mouse.x, mouse.y);
        if(wh) { draggingHandle = wh; selectWire(wh); return; }
        const term = getTerminalUnderMouse(mouse.x, mouse.y);
        if(term) { drawingWire = true; wireStartTerm = term; selectWire(null); return; }
        const gen = components.find(c => c.type === 'Gen');
        if (gen.checkSwitchClick(mouse.x, mouse.y)) { analyzeCircuit(); draw(); return; }
        const wClicked = getWireUnderMouse(mouse.x, mouse.y);
        if(wClicked) { selectWire(wClicked); draw(); return; }
        for(let i=components.length-1; i>=0; i--) {
            if(components[i].contains(mouse.x, mouse.y)) {
                draggingComp = components[i];
                dragOffset = {x: mouse.x - draggingComp.x, y: mouse.y - draggingComp.y};
                components.push(components.splice(i,1)[0]);
                selectWire(null); break;
            }
        }
        if(!draggingComp && !wClicked && !drawingWire && !draggingHandle) selectWire(null);
        draw();
    });

    window.addEventListener('mousemove', e => {
        mouse = getMousePos(e);
        if(draggingHandle) { draggingHandle.cp = {x: mouse.x, y: mouse.y}; draw(); return; }
        if(draggingComp) {
            draggingComp.x = mouse.x - dragOffset.x;
            draggingComp.y = mouse.y - dragOffset.y;
            draggingComp.x = Math.max(draggingComp.w/2, Math.min(canvas.width-draggingComp.w/2, draggingComp.x));
            draggingComp.y = Math.max(draggingComp.h/2, Math.min(canvas.height-draggingComp.h/2, draggingComp.y));
            analyzeCircuit();
        }
        let cursor = 'default';
        if(getWireHandleUnderMouse(mouse.x, mouse.y)) cursor = 'pointer';
        else if(getTerminalUnderMouse(mouse.x, mouse.y)) cursor = 'crosshair';
        else if(components.find(c=>c.type==='Gen').contains(mouse.x, mouse.y) && mouse.x > components.find(c=>c.type==='Gen').x - 70 && mouse.x < components.find(c=>c.type==='Gen').x - 30) cursor = 'pointer'; 
        else if(components.some(c=>c.contains(mouse.x,mouse.y))) cursor = 'grab';
        else if(getWireUnderMouse(mouse.x, mouse.y)) cursor = 'pointer';
        canvas.style.cursor = cursor;
        draw();
    });

    window.addEventListener('mouseup', () => {
        if(drawingWire && wireStartTerm) {
            const term = getTerminalUnderMouse(mouse.x, mouse.y);
            if(term && term.id !== wireStartTerm.id) {
                const p1 = {x:wireStartTerm.x, y:wireStartTerm.y};
                const p2 = {x:term.x, y:term.y};
                const cp = { x: (p1.x+p2.x)/2, y: (p1.y+p2.y)/2 };
                wires.push({ startId: wireStartTerm.id, endId: term.id, startC: wireStartTerm.c, endC: term.c, color: currentColor, cp: cp });
                analyzeCircuit();
            }
        }
        drawingWire = false; draggingComp = null; draggingHandle = null; draw();
    });

    window.addEventListener('keydown', (e) => { if((e.key === 'Delete' || e.key === 'Backspace') && selectedWire) deleteSelectedWire(); });
    window.setColor = (c) => { currentColor = c; document.querySelectorAll('.color-selector').forEach(el => el.classList.toggle('active', el.title.toLowerCase().includes(c==='red'?'rouge':(c==='green'?'vert':'noir')))); };
    function selectWire(w) { selectedWire = w; btnDel.style.opacity = selectedWire ? '1' : '0.5'; }
    window.deleteSelectedWire = () => { if(selectedWire) { wires = wires.filter(w => w !== selectedWire); selectWire(null); analyzeCircuit(); draw(); } };
    window.undoWire = () => { wires.pop(); selectWire(null); analyzeCircuit(); draw(); };
    window.clearWires = () => { wires = []; selectWire(null); analyzeCircuit(); draw(); };

    // --- DESSIN ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#e9ecef'; ctx.fillRect(0,0,SHELF_WIDTH,canvas.height);
        ctx.strokeStyle = '#ced4da'; ctx.beginPath(); ctx.moveTo(SHELF_WIDTH,0); ctx.lineTo(SHELF_WIDTH,canvas.height); ctx.stroke();
        ctx.fillStyle = '#adb5bd'; ctx.font="bold 14px Arial"; ctx.fillText("MATÉRIEL", 50, 30);

        components.forEach(c => {
            if(c.type === 'Gen') drawGen(c);
            if(c.type === 'Lamp') drawLamp(c);
            if(c.type === 'Multi') drawMulti(c);
        });

        let termCounts = {};
        wires.forEach(w => {
            let idxStart = termCounts[w.startId] || 0; termCounts[w.startId] = idxStart + 1;
            let idxEnd = termCounts[w.endId] || 0; termCounts[w.endId] = idxEnd + 1;

            const p1Base = getTermPos(w.startC, w.startId);
            const p2Base = getTermPos(w.endC, w.endId);
            
            const offX = 3; const offY = -12; 
            const p1 = { x: p1Base.x + (idxStart * offX), y: p1Base.y + (idxStart * offY) };
            const p2 = { x: p2Base.x + (idxEnd * offX), y: p2Base.y + (idxEnd * offY) };

            if(!w.cp) w.cp = {x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2};
            
            drawWireStack(p1, p2, w.cp, w.color, (w === selectedWire));
        });

        if(drawingWire) {
            const p1 = {x: wireStartTerm.x, y: wireStartTerm.y};
            const snap = getTerminalUnderMouse(mouse.x, mouse.y);
            const p2 = snap ? {x: snap.x, y: snap.y} : mouse;
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = (currentColor === 'black') ? COL_BLACK : (currentColor === 'red' ? COL_RED : COL_GREEN);
            ctx.lineWidth = 4; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
        }
        
        if(!drawingWire && !draggingComp) {
            const h = getTerminalUnderMouse(mouse.x, mouse.y);
            if(h) { ctx.beginPath(); ctx.arc(h.x, h.y, 8, 0, Math.PI*2); ctx.strokeStyle = '#3498db'; ctx.lineWidth = 3; ctx.stroke(); }
            const wh = getWireHandleUnderMouse(mouse.x, mouse.y);
            if(wh || draggingHandle) {
                const target = wh || draggingHandle;
                ctx.beginPath(); ctx.arc(target.cp.x, target.cp.y, 6, 0, Math.PI*2);
                ctx.fillStyle = 'white'; ctx.fill(); ctx.strokeStyle = '#2c3e50'; ctx.lineWidth=2; ctx.stroke();
            }
        }
    }

    function getTermPos(comp, termId) {
        const terms = comp.getTerminals();
        for(let k in terms) if(terms[k].id === termId) return terms[k];
        return {x:0, y:0};
    }

    function drawWireStack(p1, p2, cp, color, selected=false) {
        const visColor = (color === 'black') ? COL_BLACK : (color === 'red' ? COL_RED : COL_GREEN);
        
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.quadraticCurveTo(cp.x, cp.y, p2.x, p2.y);
        ctx.strokeStyle = visColor;
        ctx.lineWidth = 6; ctx.lineCap = 'round';
        
        if(selected) { ctx.shadowColor = "#e67e22"; ctx.shadowBlur = 15; ctx.lineWidth = 8; } 
        else { ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.shadowBlur = 5; ctx.shadowOffsetY = 3; }
        ctx.stroke(); ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
        
        if(!selected) { ctx.lineWidth = 2; ctx.strokeStyle = "rgba(255,255,255,0.2)"; ctx.stroke(); }
        
        drawBananaPlug(p1, color);
        drawBananaPlug(p2, color);

        if(selected) { ctx.beginPath(); ctx.arc(cp.x, cp.y, 5, 0, Math.PI*2); ctx.fillStyle = '#e67e22'; ctx.fill(); } 
    }
    
    function drawBananaPlug(p, color) {
        const visColor = (color === 'black') ? COL_BLACK : (color === 'red' ? COL_RED : COL_GREEN);
        
        ctx.fillStyle = visColor;
        ctx.strokeStyle = (color === 'black') ? '#bbbbbb' : 'rgba(0,0,0,0.4)'; 
        ctx.lineWidth = 1;
        
        ctx.beginPath();
        ctx.roundRect(p.x - 7, p.y - 12, 14, 24, 4); 
        ctx.fill(); ctx.stroke();
        
        ctx.fillStyle = '#1a1a1a'; 
        ctx.beginPath(); ctx.arc(p.x, p.y - 7, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = visColor; ctx.lineWidth = 1; ctx.stroke();
    }

    function drawGen(c) {
        ctx.save(); ctx.translate(c.x, c.y);
        drawRoundBox(-80,-55,160,110,10,'#2d3436'); 
        ctx.fillStyle='#222'; ctx.fillRect(-60,-40,120,80);
        ctx.fillStyle='black'; ctx.fillRect(-50,-10,20,30);
        if(c.isGenOn) { ctx.fillStyle='#333'; ctx.fillRect(-50,-10,20,15); } else { ctx.fillStyle='#333'; ctx.fillRect(-50,5,20,15); }
        ctx.beginPath(); ctx.arc(-15,5,6,0,Math.PI*2); 
        if(c.isGenOn) { ctx.fillStyle='#ff3f34'; ctx.shadowColor='red'; ctx.shadowBlur=15; ctx.fill(); ctx.shadowBlur=0; } else { ctx.fillStyle='#500'; ctx.fill(); }
        ctx.fillStyle = '#bdc3c7'; ctx.font = "bold 10px Arial"; ctx.textAlign = "center";
        ctx.fillText("ON", -40, -15); ctx.fillText("OFF", -40, 32);
        ctx.save(); ctx.translate(35,5); 
        ctx.fillStyle = '#ecf0f1'; ctx.font="bold 9px Arial";
        const voltages = ["3", "4.5", "6", "9", "12"];
        const radius = 24;
        for(let i=0; i<voltages.length; i++) {
            const ang = Math.PI - (i * (Math.PI / (voltages.length - 1))); 
            const tx = Math.cos(ang) * radius; const ty = -Math.sin(ang) * radius;
            ctx.fillText(voltages[i], tx, ty);
        }
        ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); ctx.fillStyle='#333'; ctx.fill();
        ctx.rotate(-0.5); ctx.fillStyle='#e67e22'; ctx.fillRect(-3,-3,6,-12);
        ctx.restore();
        drawT(8, 35, 'black', '-'); drawT(38, 35, 'red', '+');
        ctx.restore();
    }

    function drawLamp(c) {
        ctx.save(); ctx.translate(c.x, c.y);
        drawRoundBox(-30,0,60,32,4,'#2d3436');
        ctx.fillStyle='#bdc3c7'; ctx.fillRect(-10,-12,20,12);
        ctx.strokeStyle='#7f8c8d'; ctx.beginPath(); ctx.moveTo(-10,-10); ctx.lineTo(10,-10); ctx.stroke();
        ctx.translate(0,-12);
        
        ctx.beginPath(); ctx.arc(0,-20,24,0,Math.PI*2); 
        
        if(c.isOn) { 
            // COULEURS MODIFIÉES POUR PÉDAGOGIE
            let coreColor, haloColor, blurAmount;

            if(c.currentIntensity >= 0.3) {
                // FORTE : Jaune/Orange saturé ("Foncé" visuellement)
                coreColor = '#f39c12';
                haloColor = '#f1c40f';
                blurAmount = 50;
            } else {
                // FAIBLE : Jaune très pâle / Crème ("Clair")
                coreColor = '#fff9c4'; 
                haloColor = 'rgba(255, 255, 200, 0.5)';
                blurAmount = 15;
            }

            // Halo externe
            ctx.shadowColor = haloColor; 
            ctx.shadowBlur = blurAmount; 
            ctx.fillStyle = coreColor;
            ctx.fill(); 
            
            // Halo interne
            ctx.shadowBlur = 10; 
            ctx.fillStyle = coreColor; 
            ctx.fill(); 
        } else { 
            ctx.fillStyle = 'rgba(230,240,255,0.4)'; ctx.fill(); ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth=1; ctx.stroke(); 
            ctx.beginPath(); ctx.arc(-8,-30,4,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.5)'; ctx.fill(); 
        }
        ctx.shadowBlur = 0; ctx.translate(0,12);
        drawT(-20, 15, 'black'); drawT(20, 15, 'black');
        ctx.fillStyle='#ecf0f1'; ctx.font="bold 12px Arial"; ctx.fillText(c.label, -8, 28);
        ctx.restore();
    }

    function drawMulti(c) {
        ctx.save(); ctx.translate(c.x, c.y);
        const scale = 0.7; ctx.scale(scale, scale);
        drawRoundBox(-60,-90,120,200,10,'#ecf0f1');
        ctx.fillStyle='#95a5a6'; ctx.fillRect(-60,-50,5,120); ctx.fillRect(55,-50,5,120);
        ctx.fillStyle='#bdc3c7'; ctx.fillRect(-50,-80,100,45);
        ctx.fillStyle='#2c3e50'; ctx.font="bold 26px monospace"; 
        let txt = "0.00"; if(c.measuredValue > 0 && components.find(x=>x.type==='Gen').isGenOn) txt = c.measuredValue.toFixed(2);
        ctx.fillText(txt, -30, -48);
        ctx.lineWidth=10; 
        ctx.beginPath(); ctx.arc(0,10,40,Math.PI*0.6, Math.PI*1.1); ctx.strokeStyle='#e056fd'; ctx.stroke(); 
        ctx.beginPath(); ctx.arc(0,10,40,Math.PI*1.1, Math.PI*2.1); ctx.strokeStyle='#3498db'; ctx.stroke(); 
        ctx.beginPath(); ctx.arc(0,10,40,Math.PI*2.1, Math.PI*2.6); ctx.strokeStyle='#2ecc71'; ctx.stroke(); 
        ctx.lineWidth=1; ctx.strokeStyle='#ccc';
        ctx.beginPath(); ctx.arc(0,10,25,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); ctx.stroke();
        ctx.save(); ctx.translate(0,10); ctx.rotate(Math.PI*0.8); ctx.fillStyle='#999'; ctx.beginPath(); ctx.moveTo(0,-20); ctx.lineTo(-5,0); ctx.lineTo(5,0); ctx.fill(); ctx.restore();
        ctx.scale(1/scale, 1/scale);
        drawT(-15, 50, 'black', 'COM'); drawT(25, 50, 'yellow', '10A');
        ctx.fillStyle='#7f8c8d'; ctx.font="bold 10px Arial"; ctx.fillText(c.label, 0, -5);
        ctx.restore();
    }

    function drawRoundBox(x,y,w,h,r,fill) { ctx.beginPath(); if(ctx.roundRect) ctx.roundRect(x,y,w,h,r); else ctx.rect(x,y,w,h); ctx.fillStyle=fill; ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.2)'; ctx.lineWidth=1; ctx.stroke(); }
    function drawT(x,y,c,l) { ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fillStyle = c==='red'?'#c0392b':(c==='black'?'#2d3436':'#f1c40f'); ctx.fill(); ctx.beginPath(); ctx.arc(x,y,2,0,Math.PI*2); ctx.fillStyle='#ccc'; ctx.fill(); if(l) { ctx.fillStyle='#555'; ctx.font="9px Arial"; ctx.fillText(l, x, y-10); } }
    if (!ctx.roundRect) ctx.roundRect = function(x,y,w,h,r){this.rect(x,y,w,h)};
    init();

</script>
</body>
</html>
